#include <iostream>
using namespace std;

int randint(int start, int end) {
    int num = start + rand() % (end - start + 1);
    return num;
}

void address_operator() {  // оператор адреса
    int b = 10;
    int arr[3] = {21, 15, 6};
    cout << "b = " << b << endl;
    // чтобы получить адрес переменной, нужен оператор адреса &
    cout << "&b = " << &b << endl;

    /** массивы тоже сохраняются в ячейки, но
     * получить адрес самого массива НЕЛЬЗЯ, потому что
     * его нет. Если попытаться получить адрес массива,
     * вы получите адрес его первого элемента. Элементы
     * массива располагаются в один ряд рядом друг
     * с другом **/

    cout << "&arr = " << &arr << endl;
    cout << "&arr[0] = " << &arr[0] << endl;
    cout << "&arr[1] = " << &arr[1] << endl;
    cout << "&arr[2] = " << &arr[2] << endl;
}

void dename_operator() {  // оператор разыменования
    int b = 10;
    int arr[3] = {21, 15, 6};
    cout << "b = " << b << endl;
    cout << "&b = " << &b << endl;
    /* оператор * (не путать с умножением)
    разыменовывает значение адреса ячейки переменной
    Оператор обращается к адресу, находит там значение,
    конвертирует его и показывает то, что находилось в этом адресе */
    cout << "*&b = " << *&b << endl;
}

void pointers() {  // указатели
    int b = 10;  // переменная
    int *c = &b;  // указатель (ссылка) на ячейку, присвоенную переменной b (c = 10)
    // если звездочка стоит при объявлении/инициализации переменной - это указатель
    cout << "b = " << b << endl;
    cout << "&b = " << &b << endl;

    cout << "c = " << c << endl;
    // оператор разыменования позволяет получить значение указателя
    cout << "*c = " << *c << endl;
    // если звездочка стоит около переменной во время вывода/выполнения действий - это оператор разыменования

    /* Значение указателя изменить нельзя (напрямую), потому что
     * значением указателя может быть только адрес переменной. Но
     * его можно поменять, если присвоить новое значение переменной,
     * на которую ссылается указатель.*/
    b += 7;
    cout << "*c = " << *c << endl;
    cout << 15 + *c << endl;  // использовать значение указателя можно
    // c = 32, но менять его значение напрямую НЕЛЬЗЯ

    /* Указатель - это переменная, значением которой является НЕ
     * какое-то число, а адрес ячейки переменной. Указатели
     * объявляются так же, как обычные переменные, но имеют
     * звездочку между именем и типом данных.
     *
     * Воспринимайте указатель в С++, так же, как указатели
     * на ваш дом. */
}

void how_to_pointer() {  // как объявлять указатели
    /* ПРАВИЛО - пишите звездочку рядом с именем указателя */
    int *iPtr;  // можно - объявил целочисленный указатель iPtr;
    double *dPtr;  // можно - объявил вещественный указатель dPtr;

    int* iPtr1;  // допустимо, но лучше так их не объявлять
    int * iPtr2;  // допустимо, но лучше так их не объявлять

    int *iPtr3, *iPtr4, *iPtr5;  // можно объявлять сразу несколько указателей (как и переменных)
    double *dPtr2, dPtr3;  // указатель - dPtr2, а dPtr3 - это обычная переменная
}

void dynamic_array() {
    int count;
    cout << "Введите количество: ";
    cin >> count;

    // инициализация указателя на динамический массив scores длинной count
    int *scores = new int[count];  // new - оператор создания динамического массива
    for (int i = 0; i < count; i++) {
        cout << "№" << i + 1 << ": ";
        cin >> scores[i];
    }
    // узнать длинну динамического массива нельзя, потому что сам массив представляет собой указатель
    // cout << sizeof(scores) / sizeof(scores[0]) << endl;
    scores = nullptr;
}

void mid_sum() {
    srand(time(NULL));
    int size = randint(5, 10);
    int *marks = new int[size];
    double sum, mid;
    for (int i = 0; i < size; i++) {
        marks[i] = randint(1, 10);
        sum += marks[i];
        cout << marks[i] << "\t";
    }
    mid = sum / size;
    cout << mid << endl;
    /* После динамического выделения памяти
     * порядочные программисты память очищают.
     * Чтобы удалить динамический массив,
     * можно использовать ключевое слово delete
     * или присвоить массиву нулевой указатель. */
    //delete[] marks;  // удаление динамического массива
    marks = nullptr;  // присвоить нулевой указатель (удалить массив)

    // программа завершится с ошибкой, потому что
    // происходит обращение к несуществующему массиву
    cout << marks[0] << endl;
}

void dynamic_array_pointer_to_element() {
    srand(time(NULL));
    int size = randint(3, 15);
    int *array = new int[size];

    // выводить элементы динамического массива можно через указатель
    for (int i = 0; i < size; i++) {
        array[i] = randint(1, 100);
        // к адресу первого элемента добавляется индекс
        // и через оператор *, он выводится на консоль
        cout << "Адрес array[" << i << "] " << array + i << " ";
        cout << "Значение: " << *(array + i) << endl;

        /* Когда вы обращаетесь как array + i - это значит
         * "взять адрес array (первого элемента) и добавить
         * к нему индекс i." - array[0] + i(1) = array[1] */
    }

}